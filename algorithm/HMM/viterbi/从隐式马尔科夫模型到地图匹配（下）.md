# 从隐式马尔科夫模型到地图匹配（下）

原创 Tecyle [夕月阁](javascript:void(0);) *2019-04-19 21:59*

快速通道：[从隐式马尔科夫模型到地图匹配（上）](http://mp.weixin.qq.com/s?__biz=MzI4MDAwMDY0OQ==&mid=2455399361&idx=1&sn=ed63070e65116e8addf939a4aed2d36c&chksm=fc11ea27cb6663310e524517e9aaecc97f99b099a4ebc7b56a18e0901b23fbcafc63ce3d5f29&scene=21#wechat_redirect)



## 再说地图匹配

上一讲，有了算法思想之后，我们再看怎样在地图匹配中应用隐式马尔科夫模型和维特比算法。

首先，我们先明确下对应关系。我们直接能拿到的 GPS 轨迹点就对应于我们骰子问题中最终记录下来的数字。而我们要求的实际经过路段，则对应于我们的骰子序列。所以，轨迹点序列就是**观测序列**，而路段序列，就是**隐藏序列**。

我们知道，要应用维特比算法的话，除了要知道**观测序列**之外，还需要知道**模型参数**。但是和骰子问题不一样，我们并不知道准确的**模型参数**。于是，我们遇到的一个问题就是，**观测概率**和**转换概率**应该怎么计算？

如果需要知道准确的**模型参数**的话，可以参考上面提到过的第三类问题的解决方法，用一些神经网络或者机器学习的方法，就可以训练处比较靠谱的参数。但是对于我们的地图匹配目标而言，完全没有必要弄的这么麻烦。

## 概率模型

虽然说，之前讨论的所有东西都是基于概率模型而言的，并且概率还得满足大于等于 0 小于等于 1 的这个要求。如果你实际计算过一个比较长的序列的概率的话，你就会发现，越到后面，计算得到的这个概率值就越接近 0。

这个现象会导致一个很直接的问题，当我的序列很长的时候，计算出来的概率值可能无法用浮点数精确表示了，导致到最后算出来的全是 0，进而无法得到正确的结果了。

对于精度的这个问题，有一个比较好的解决方法，那就是将概率值取对数，这样，不仅保持了概率的单调性（数值大表示概率大），同时，也将 [0, 1] 这样范围内的一个数一一映射到了 (-∞, 0]，这样就不用担心序列太长浮点数不够表示的问题了。注意，概率 0 映射的点是 -∞，-∞ 这个数是可以用浮点数表示。

映射成对数还有一个好处，那就是原本我们计算中的所有概率计算都是乘法，而换成对数之后，==所有的乘法都变成加法了==，计算速度也大大提升了。

其实，考虑到这里，下一步就应该去考虑该用什么概率模型了，正态分布还是指数分布之类的。实际上，仔细看下我们的维特比算法的实现，我们发现，整个计算过程中，这个概率值我们只关心它们之间的大小比较，并不关心数值范围！

那么问题就可以简单处理了，我们在设定观测概率和转换概率的时候，只需要指定一个符合趋势的“代价值”就好了。

所以，我们都不需要用浮点数来计算了。直接用一个正整数来比较代价，而在运用维特比算法的时候，我们将代价小的点作为概率高的点来处理就可以了。

举个例子说，一个定位点对应于一条路段，应该满足什么规律呢？很明显的一个规律就是，这个点离这个路段越远，这个点实际上在这个路段的概率就越小。

![20230313224606.png](image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230313224606.png)

如上图所示，颜色深的点表示概率大的点，颜色浅的点表示概率小的点。所以，我们在设置代价值的时候，应该满足的规律就是，==点离路段越远，这个代价值越大==。至于具体给多少，看实际测试案例，比如 5，或者是 500，只要最后比较大小的时候跟经验一致即可。

另外还可以再考虑上观测点的前进方向和实际路段的通行方向之间的差异，==方向差异越大，代价也就越大==。当然，整体的观测概率可以是这两个代价的加权平均，数值是多少，完全看你更相信距离误差还是更相信方向误差。

那么这里，我们总结下**观测代价**可以怎么设定。

**观测代价**可以是以下几个代价因素的加权平均：

- GPS 点到路段的==距离==；
- GPS 点前进方向和路段的==方向差==；
- GPS 点的==速度==与道路限速值的差异（低于限速值代价为 0，超过限速值就累加插值）。

如果还有其它可以列入考虑的因素，都可以加入代价值范围。

同时，还有一些特殊情况下是需要降低某些特定路段的代价的，比如：

- 路段==车道数==比较多，也就是道路比较宽，此时，距离代价应适当降低；
- GPS 的==精度==较低的时候，距离和方向等代价应适当降低；
- GPS 速度较低的时候，方向代价应适当降低；
- 路段处于容易==飘星==的地段的时候（比如高架桥下，高楼或湖泊旁边），距离代价应适当降低。

通过调整以上或者更多我没有列出的因素之后，可以获得很好的匹配效果。

接下来，我们总结下**转换代价**可以怎么设定。

**转换代价**是指从上一个点到这一个点的前进过程中，从**上一个点对应的某个路段**到**这个点对应的某个路段**的代价。一个最简单的考虑就是，<u>两个观测点之间的距离</u>，和<u>两个路段之间的对应点之间的距离</u>应该差不多相等。

![微信图片_20230314160133.png](image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230314160133.png)

如上图所示，假设，==蓝色==的两个点是观测到的两个 GPS 信号点，他们之间的距离是 10 米。==红色==的路段上的两个红点分别对应于两个 GPS 点所对应的在路线 A 上的两个观测对应点，==绿色==的路段上的两个绿点分别对应于两个 GPS 点所对应的在路线 B 上的两个观测对应点。

在红色的路线 A 上，从左边的点沿着路线到右边的点，经过的距离是 9 米，这个转换更接近实际 GPS 的转换，我们认为其转换代价应该为 |10-9| = 1 米。

在绿色的路线 B 上，从左边的点沿着路线到右边的点，经过的距离是 25 米。我们认为，这个路线离实际 GPS 的走势相差更大，所以认为其转换代价应该为 |10-25| = 15 米。

通过这样的代价设置（当然，可以加上权重），我们会有更大的概率取选择转换距离和实际 GPS 间隔更加接近的点。

**转换代价**除了可以考虑转换==距离差==这个基本的因素之外，还可以考虑以下因素：

- ==转换方向==，就是指 GPS 在这两个点之间的方向，以及路段上这两个点的方向，通过这个**方向差**来设置代价。比如 GPS 是向西走的，但是候选的路段是向北走的，那么这样的候选路段就应该加大代价。
- ==特殊路段==。比如，某个转换是从**大道转换到自行车道**上的，实际上行车的话很少会进出自行车道的，所以这种转换应该加上代价。
- 路段侧位。比如两个 GPS 观测，对应两个候选，一个候选，GPS 位于路段的两侧，另一个候选，GPS 位于路段的同一侧，这种情况下，应该去选择都位于路段同一侧的候选，也就是位于路段两侧的的候选路段需要加大代价。
- 特别的，如果路段转换距离是 0，但是 GPS 观测转换距离存在的话，那么，这种路段应该加大代价。一般来说，路段转换距离是 0 的话，意味着两个 GPS 点都抓在同一个地方，这种情况下，往往不是一个正确的匹配结果。

除了上面列出的因素之外，还有其它我没有考虑到的因素也可以往里加，通过加权平均的方式来协调各个因素对最终匹配结果的影响大小。

上面的**观测代价**和**转换代价**就构成了我们的**模型参数**了。但是目前，这些参数都是我们凭自己的经验值给出的，然后在开发后期，可以通过实际案例来逐步调整这些参数值。实际上，用上深度学习或者神经网络的方法，可以自动回归这些参数，甚至可以通过统计特定位置车辆的大数据行为，来决定某个路口或者某些路段行车的可能性代价。这些都不在本文的讨论范围内，所以这里就不再赘述了。

最后再强调下，代价的计算也没必要继续用乘法了，直接相加即可。

## 再说维特比算法

现在，**观测序列**有了，**模型参数**也有了，是时候该用维特比算法来计算最有可能的行车路线，也就是**隐藏序列**了。

路网是个很大的数据，直接将所有路段都用来作为每个观测点的状态来计算观测代价和转换代价是不可能的也没有必要的。所以，在地图匹配的维特比算法中，接下来遇到的问题就是状态的选取和转换的计算。

这个地方，我遇到了两种方法。首先我们看下第一种方法，这种方法是我在某开源的 Map Matching 中看到的。

我们先看==维特比算法的第一步==怎么解决。离观测点过远的路段，被选为最合适的路径的概率是很小很小的。所以，我们==构建第一个观测点的初始路段备选集的时候，可以采用距离抓路的方法==，**在观测点方圆 200 米范围内进行路段抓取**，抓到的路段才加入第一个状态的路段备选集中。

![图片](image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230314160915.jpg)

如图中所示，所有没有在 200 米圆范围内的路段都直接丢弃，我们只保留这个经过这个圆内部的所有路段，然后，在这些路段上选择一个最合适的抓路点作为 GPS 定位信号实际上可能在这个路段上的位置。

而以后的每个点，也都采用同样的方式产生候选路段。这样的话，我们只需要将转换计算应用于这些我们选出的候选路段就可以了，而不需要进行整个路网的搜索。

![图片](image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230314161103.png)

假设我的 GPS 信号从红色的点转移到了绿色的点，而红色的路段代表红色点的候选路段，绿色的路段代表绿色点的候选路段，然后，我们怎样确定红色的路段需要走怎样的路线才能到达绿色的路段呢？这个地方，我们主需要将所有的红色路段作为起点，进行路网扩散，扩散一定的距离就停止，然后，扩散过程中，每一个红色路段到每一个绿色路段的最短路径，我们就认为这是一个红色点到绿色点的隐藏序列转换。比如下面蓝色的路段就是扩散搜索到的有效转换的路段。

![图片](image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230314161146.png)

然后，我们再在这个有效转换上进行转换代价的计算就可以了。这个搜索过程中，我们可以发现，==红色的某些路段可能无法扩散到绿色的路段上==，**那么这种红色路段我们就认为是无效的候选路段，直接剔除**。同样，也会存在某些绿色的路段无法从红色的路段扩散过来，这种绿色的路段也需要直接剔除。

经过上述步骤不断重复之后，找到最后一个点对应的代价值最小的候选路段，然后依次找到产生这个代价值的每一个前驱路段，就可以获取到最有可能的行车路线了。

总结下这种做法的步骤：

1. 对所有点序列进行遍历；
2. 对当前遍历到的点，进行周边抓路，将抓到的路标记为候选路段；
3. 如果不是第一个点，则将上一个点的所有保留下来的候选路段进行一定距离的扩散，获得范围内每两条路段之间的最短路径，仅保留起点是上一个点的备选路段且终点这个点的备选路段的路径；
4. 计算代价，计算方法为：上一个点的候选路段代价 + 到这个点对应候选路段的转换代价 + 这个点的观测代价；
5. 搜索到最后一个点的时候，找到代价最小的候选路段，然后依次往前追溯，找到计算出这个最小代价时经过的所有节点（包括转换路径上的路段）。

这种做法会存在一定的问题：

- 如果抓路代价比较大的话，这种做法速度会比较慢；
- 很多比如沿着单一高速行驶的路线，候选路线只可能有一条，但是在进行转换计算之前，仍然会抓到很多无用的候选路段；
- 转换扩散的地方，如果不借助现有的算路接口的话，自己实现起来难度比较大。

## 对上面算法进行改进

我实践了一下上面这个算法，发现路网匹配的速度非常慢，不满足实际需求，于是，我对上面的算法做了一些改进，具体如下：

首先，<u>第一个点的候选路段选择，我采用了同样的抓路方法，和上面的方法类似</u>，这里就不再赘述。

从第二个点开始，就==不再继续抓路==了（抓路的性能比较低），而是从上一个点的所有备选路径开始，向外扩散出所有可能的路线。注意，这种扩散不是迪杰斯特拉扩散，而是单纯地向外扩散，并记录产生的每一条路线。

![图片](image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230314161435.png)

比如上图中，红色的路段是我当前留下的所有候选路段，现在我要往绿色的点推进了，我就将所有红色的路段沿通行方向向外扩散，得到了所有蓝色的路段。

得到所有蓝色的路段之后，加上红色的路段，我再用绿色的点在这些路段上进行==投影==，然后过滤掉距离过远的路段，将剩下的路段作为绿色路段的候选路段。如图：

![图片](image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230314161544.png)

然后，由于红色到绿色的路段路线都已经知道了，所以这些转换都是可以直接计算了。注意，红色到绿色路段可能经过两条不同的路线，这种情况下，只需要保留最小的转换就可以了。

然后，依照这样的方法，不断往后推进即可。推进到最后一个点的时候，再依照上面的方法，查找代价最小的路段，依次往前搜索就可以获得匹配结果。

==这种方法的好处就是，抓路次数很少，并且，在只有一条可能路线的时候推进速度很快。==

但是，在双向路段比较密集的地方，扩散出来的路线数量可能非常非常多，这个地方，为了提高速度，可以进行适当的剪枝操作。比如，扩散出来的存在来来回回的路线可以删掉，再比如，存在抓路距离比较近的路段，可以把比较远的扩散删掉，等等。

通过这种扩散的方式，还可以避免最短路径计算代码的编写，转换最短路径，通过其中的最小代价选择给实现了。

我自己对比了一下上面两种算法，使用第一种算法，匹配一条路花了10几秒钟，而使用第二种方法，匹配同一条路，结果是秒出的，只用了100毫秒不到的时间。

## 一些优化

通常，我们记录下来的 GPS 轨迹是比较密集的，尤其是车速比较慢的时候（堵车，或者是等红绿灯）。这些过于密集的点如果我们都拿来做地图匹配的话，是对性能的浪费。所以，在开始做地图匹配之前，我们需要对形状点做==抽稀==。抽稀的准则就是，尽可能地不改变轨迹的形状，但是又要尽可能地少保留点。

抽稀的方法有很多，我采用的抽稀基准就是，大约50米的距离才留一个点，有以下例外：

- ==起点必须留下来==，且起点的方向不可靠，不使用起点的方向信息；
- ==终点必须留下来==，且终点的方向不可靠，不使用终点的方向信息；
- 如果出现==转动角度比较大的点==，需要将这个点也留下来；
- 在检测到==掉头的点==需要特殊处理。

除此之外，还需要对轨迹进行一些野点剔除以及方向矫正处理，使得抽稀之后的形状点能更好的反映轨迹的真实形状。

下图就是抽稀前后的对比图：

![图片](image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230314161946.jpg)

抽稀后：

![图片](image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230314162012.jpg)

将形状抽稀之后，可以大大减少算法的运行时间。

此外，还有一个值得注意的地方就是==双向路掉头==的情况。

![图片](image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230314162044.png)

如上图，**蓝色的路段是可以双向通行的路段**，然后<u>红色的轨迹点</u>反应了车辆在双向通行的路段上进行掉头的情况。可以发现的问题就是，车辆在沿着红色的路线掉头，是可以出现在双向路段上的任意位置的，但是我们在计算正反向路段的转换代价的时候，转换距离则是算上整根路段的（如蓝色接头所示），这就会造成，转换代价和实际车的转换产生很大的差异，这种情况会导致我们的匹配结果出现误判。

所以，为了解决上面这个问题，需要预==先识别出这种掉头序列==，然后再遇见掉头序列的地方，双向路转换到自身的代价应该相应地==扣除掉头距离==。

以上，就是应用维特比算法的地图匹配方法的总览，具体提升精度的方法，可以通过调整代价值实现，而提升算法速度的方法，可以通过对扩散候选路径剪枝来实现，这都有待于读者的进一步实践。



（完）