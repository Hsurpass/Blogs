# 从隐式马尔科夫模型到地图匹配（上）

原创 Tecyle [夕月阁](javascript:void(0);) *2019-04-18 22:57*

**什么是地图匹配**

首先，我们还是简单说说什么是地图匹配。做过 GIS 相关开发的童鞋应该对这个概念不陌生，所谓地图匹配，也就是 Map Matching，是指将一段离散的轨迹点匹配到实际路网上的过程。

比如，下图中，显示了一段行车 GPS 记录的轨迹点。

![图片](image/640)

但是，这个行车轨迹究竟走了哪些路段，虽然我们人眼能直接看出来，但是这个轨迹是无法直接告诉计算机它经过了哪些路段的，并且，由于信号不好等问题，记录下来的轨迹的某些部分可能还会与实际的路段相差甚远。而我们需要做的事情就是找到这样一个**路段序列**，能表示出这段轨迹实际走过的道路。如下图：

![图片](image/640)

下面的动图展示了地图匹配的动态过程，这个动态过程是采用的维特比算法，然后将计算的每个中间过程都以图形的方式展现出来了：

![图片](image/640)

**从简单的例子说起**

网上有很多关于地图匹配的算法，其中，大部分都是基于隐式马尔科夫模型来实现的。在这里，我不想讲太多数学公式上的定义和推论，我们就直接从例子开始说起。

假设我有三种类型的骰子：

1. 正四面体的骰子，我们将其简称为 **D4**，可以随机投出 1,2,3,4 中的任意一个数字。
2. 正六面体的骰子，也就是立方体的骰子，我们将其简称为 **D6**，可以随机投出 1,2,3,4,5,6 中的任意一个数字。
3. 正八面体的骰子，我们将其简称为 **D8**，可以随机投出 1,2,3,4,5,6,7,8 中的任意一个数字。

由于骰子是均匀的，所以我们认为每次投出来每个数字的概率都是相等的。也就是说，**D4** 投出 1 到 4 中的每个数字的概率都是 1/4。**D6** 投出 1 到 6 中的每个数字的概率都是 1/6。**D8** 投出 1 到 8 中的每个数字的概率都是 1/8。

现在，我们要以一定的规则来投掷出一串数字，具体的规则如下：

- 刚开始的时候，我随机选择任意一个骰子来投掷出一个数字，也就是说，每个骰子被选中的概率都是 1/3。
- 以后的每一次投掷，我都以 1/2 的概率选择沿用上一次选择的骰子，或者分别以 1/4 的概率选择另外两个骰子。

那么，对应于这么一个场景，我们可以提出下面这三类问题：

1. 已知我每次选用的骰子是哪一个，比如这个序列是 “**D4**-**D6**-**D6**-**D8**”，并且已知我投掷出的数字序列，比如是 “2-6-4-6”，那么我想知道，我投掷出这个序列的概率是多少？
2. 已知我最终记录下来的数字序列，比如是 “2-6-4-6”，我想知道，投出这个序列的最大可能的骰子序列是哪一组？
3. 问题可以更夸张一些，我不知道骰子是不是均匀的（意思就是，我不知道骰子投出每个数字的概率是多少），也不知道我每次投掷都是以什么样的概率去选择骰子的，但是我有很多组记录下来的数字序列，我想根据这些数字序列来反推出我所有不知道的概率值是多少？

上面的三个问题代表了隐式马尔科夫模型能解决的三大问题，每一类问题都有对应的算法。

为了规范后面的描述，我们先做一下术语定义：

- 上面提到的骰子序列，我们称之为**隐藏序列**；
- 上面提到的数字序列，我们称之为**观测序列**；
- 上面提到的骰子的投掷概率，我们称之为**观测概率**；
- 上面提到的骰子的选择概率，我们称之为**转换概率**；
- 观测概率和转换概率我们将其称之为**模型参数**。

那么，上面提到的三类问题，可以抽象为：

1. 已知**隐藏序列**和**模型参数**，求**观测序列**的概率。
2. 已知**观测序列**和**模型参数**，求最大可能的**隐藏序列**。
3. 已知大量的**观测序列**，确定**模型参数**。

现在，我们来确定下我们的地图匹配属于哪一类问题。很容易就能想到，我们的 GPS 轨迹就是我们实际的观测结果，而实际走过的路段，则类似于骰子一样，我选择了这条路段，然后我在这个路段上的 GPS 定位又有一定概率的观测误差。所以，轨迹就对应于我们说的**观测序列**，而要求解的实际走过的路段序列则对应于我们说的**隐藏序列**，我们要通过**观测序列**来求解**隐藏序列**，这就对应于我们上面说的第二类问题。而这一类问题的最常用求解方法就是维特比算法（Viterbi Algorithm）。

**概率的计算**

要求解我们的第二类问题，我们先从以下几个问题讨论起。

先从最简单的情况开始说起，假设已知我观测到的数字是 2，那么我用哪个骰子的概率最大？

我们先计算下，如果我用的是 **D4**，那么投出 2 的概率为：

P(**D4**) = 1/3 * 1/4 = 1/12

上面式子的意思是，先从三个骰子中选中 **D4** 的概率为 1/3，然后在此基础上，投出 2 的概率是 1/4，所以，总的概率就是两个数相乘。

那么，同样的，我们可以计算另外两个骰子投出 2 的概率：

P(**D6**) = 1/3 * 1/6 = 1/18

P(**D8**) = 1/3 * 1/8 = 1/24

所以，对比上述三个概率，可以知道，当观测序列是 “2” 的时候，最有可能的骰子序列为 “**D4**”。

那么继续上一个问题，我进行了第二次投掷，观测到的数字是 6，那么，这两次投掷使用的骰子序列最有可能是什么样的？

假设我观测到 6 使用的是 **D4**，这显然是不可能的，**D4** 只能投出 1 到 4 中的数字。所以，第二次使用的骰子是 **D4** 的概率为 0。

那么，我再假设我观测到 6 使用的是 **D6**，那么我们看上一次（也就是第一次），上一次可能性有三个，分别是 **D4**, **D6** 和 **D8**。下面分情况讨论下：

1. 第一次使用的是 **D4**，则第二次是 **D6** 且观测到 “2-6” 的概率为：

   P(**D4**-**D6**) = P(**D4**) * 1/4 * 1/6 = 1/12 * 1/24 = 1/288

其含义为，第一次选择了 **D4**，概率是 P(**D4**)，然后在这个基础上，又选择了 **D6**，根据之前的概率定义可以知道，上一次选了 **D4** 的话，下一次选择 **D6** 的概率是 1/4。所以，P(**D4**) 需要先乘以 1/4。然后在选择了 **D6** 的前提下，投出 6 的概率是 1/6，所以需要再乘以 1/6 得到最终的概率。

2. 第一次使用的是 **D6**，则第二次是 **D6** 且观测到 “2-6” 的概率为：

   P(**D6**-**D6**) = P(**D6**) * 1/2 * 1/6 = 1/216

式子的含义一样，就不再解释了。

3. 第一次使用的是 **D8**，则第二次是 **D6** 且观测到 2-6 的概率为：

   P(**D8**-**D6**) = P(**D8**) * 1/4 * 1/6 = 1/576

同样的道理，假设我观测到 6 使用的是 **D8**，则所有可能的概率计算为：

P(**D4**-**D8**) = P(**D4**) * 1/4 * 1/8 = 1/384

P(**D6**-**D8**) = P(**D6**) * 1/4 * 1/8 = 1/576

P(**D8**-**D8**) = P(**D8**) * 1/4 * 1/8 = 1/768



上面就已经列举了所有可能的情况了，从计算得到的最终概率值来看，概率最大的是：

P(**D6**-**D6**) = P(**D6**) * 1/2 * 1/6 = 1/216

所以我们认为，观测到 “2-6” 的话，最有可能的骰子序列为 “**D6**-**D6**”。

同样的，我们将问题扩展到任意长度的序列，然后求解最有可能的隐藏序列的话，领导性思想就是，将所有的可能性都试一遍，然后选出概率最大的那个序列。

**维特比算法**

我们将求解最有可能的骰子序列的计算步骤抽象一下。

首先，当我们的观测序列长度为 1 的时候，这个时候我们可以直接计算出选哪个骰子的概率是最大的。这一点想必屏幕前的各位都能很快算出来。

然后我们沿着观测序列往后走，当我走到第 n 个节点的时候，我要计算这个节点选择三种骰子投出观测到的数字的概率是多少的话，上一节我们说过这个计算方法，==第 n 个节点的概率仅和第 n-1 个节点计算出来的概率有关系==。这么说可能不直观，例如，我已经计算出 P(...-D4) = a，那么 P(...-D4-D4) = P(...-D4) * 1/2 * 1/4 = a * 1/8。**也就是说，我往后计算概率的时候，只需要用到第 n-1 个节点的计算结果。**

就这样往后推算，算到最后一个节点的时候，选取一个概率值最大的节点，然后这个节点往前依次查找得到这个概率的每个节点，就可以知道最大概率的隐藏序列是什么了。

其实，上面的步骤就是维特比算法的步骤了，不过说的比较乱，我们再来重新理一遍。

1. 初始化第一个观测点的所有可能状态（对应于骰子问题，状态就指选用哪个骰子）概率。

2. 从前往后遍历每一个状态，对于每一个状态，用以下方法计算当前观测点的所有可能状态的概率：

3. 1. 遍历当前观测可能对应的所有状态；
   2. 对每个状态，遍历所有上一状态，通过公式 ==P(当前状态) = P(上一状态) * P(上一状态转移到当前状态) * P(当前状态观测)== 来计算当前状态的概率。

4. 当所有观测点都遍历完之后，查找概率值最大的那个状态，然后查找这个概率值对应的上一状态，就这样一路往回找，所找到的序列（倒序的）就是最大概率的隐藏序列。

以上就是维特比算法的步骤了，其实思路很简单的，没有什么复杂的公式和数学原理。



（未完待续...）