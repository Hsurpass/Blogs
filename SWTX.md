# 目录

- [目录](#目录)
- [后端架构](#后端架构)
  - [为什么采用多进程架构？](#为什么采用多进程架构)
  - [ncserver的两个功能](#ncserver的两个功能)
    - [reload数据无需重启](#reload数据无需重启)
    - [自动补充worker进程](#自动补充worker进程)
  - [ncserver的压测](#ncserver的压测)
- [差路剔除算法](#差路剔除算法)
- [选路算法](#选路算法)
  - [怎么让他聚成三个类呢?](#怎么让他聚成三个类呢)
  - [相似度是怎么计算的。](#相似度是怎么计算的)
  - [聚类后组内排序的规则](#聚类后组内排序的规则)
- [地图匹配算法](#地图匹配算法)
  - [初始代价计算？](#初始代价计算)
  - [下一时刻的状态如何获得？](#下一时刻的状态如何获得)
    - [扩散距离如何计算？](#扩散距离如何计算)
    - [当前状态的代价如何计算？](#当前状态的代价如何计算)
  - [观测代价模型](#观测代价模型)
    - [投影怎么计算？](#投影怎么计算)
  - [转换代价模型](#转换代价模型)
    - [路段上的坡度怎么计算？](#路段上的坡度怎么计算)
  - [回溯](#回溯)
- [客户端引擎](#客户端引擎)
  - [架构](#架构)
  - [功能](#功能)
    - [拼接各种网络请求](#拼接各种网络请求)
      - [拼接算路请求](#拼接算路请求)
    - [导航](#导航)
      - [导航进度](#导航进度)
    - [偏航](#偏航)
      - [偏航判定](#偏航判定)
        - [gps偏航判定](#gps偏航判定)
        - [高架偏航判定](#高架偏航判定)
        - [坡度偏航判定](#坡度偏航判定)




# 后端架构

[nginx+fastcgi](nginx/fastcgi.md)。nginx和fastcgi进程之间和使用unix域套接字进行通信，也可以使用ip+port的形式进程通信。需要修改nginx的配置文件nginx.conf中的fastcgi_pass等参数。 

进程之间不会共享全局变量、信号处理函数，fork之后就是单独的进程了。

## 为什么采用多进程架构？

1. 一个原因是进程之间不会相互影响，一个进程崩溃了，不会影响其他进程。
2. 第二个原因是利用linux操作系统的==写时复制(copy-on-write)==的的特性。由于程序只是需要访问数据，不需要改数据，所以多个进程之间共享静态内存，即使开很多进程也不会占用太多的内存。

## ncserver的两个功能

boss进程创建manager进程，manager进程创建worker进程，worker进程的数量由配置文件指定。**静态数据的加载是在manager进程中进行的**，先加载数据再进行fork，这样就利用了写时复制的特性。

### reload数据无需重启

主要用在日更数据的更新上，当数据更新时，不需要手动重启，只需设置一个定时脚本来发送reload信号。

在boss进程中注册一个SIGUSR1的信号处理函数，当boss进程收到==SIGUSR1==信号时，fork一个新的进程作为manager进程，然后新的manager进程再去创建新的worker进程，==当所有的worker进程都创建完成时==，会向旧的manager进程发送一个终止信号(SIGTERM)，收到终止信号后，开始回收worker进程，直到所有worker进程都被回收，manager进程也就结束了。至此，这个reload流程结束。

![image-20230320164845169](image/image-20230320164845169.png)

### 自动补充worker进程

某个进程崩溃了或者被杀掉了（==都会产生SIGCHLD信号==），manager进程会马上fork出一个worker进程补充上。也就是说manager进程中有一个循环，不断的在检查worker进程的数量。

流程：循环遍历每个worker进程的pid，使用 `waitpid(m_children[i], NULL, WNOHANG);`如果返回值大于0，说明某个进程退出了；则manager进程立刻fork出一个worker进程。



## ncserver的压测

压测工具使用apache benchmark: ab -n 100000 -c 200 。 -n：表示一共发送多少请求，-c：表示并发数。

最大并发可以达到200。

可以通过spawn-fcgi -b backlog修改全连接的队列的容量来修改增加并发，还可以通过修改内核参数：net.core.somaxconn, net.ipv4.tcp_max_syn_backlog.

# 差路剔除算法

1. ==找差异==：路线之间两两比较，先找到相同路段的下标，从而直到差异路段的下标。
2. ==算分==：然后根据路线长度、eta、红绿灯个数、收费金额等(乘以对应的系数)，计算出差异部分的代价值。
3. ==丢弃==：如果两条路代价的比值大于1.68，则丢弃较差的那条。

# 选路算法

主要使用dbscan算法。dbscan算法有两个重要的参数，eps和minpts：eps代表邻域的半径，minpts代表邻域内至少有多少点。

dbscan算法的主要流程就是：

1. 第一步先初始化，把所有点标记为未访问的。
2. 然后第二步，在数据集中任选一点p，找到从点p出发所有与它密度相连的点，形成一个簇。
3. 第三步，重复步骤二，直到数据集中的所有点都被访问或者被标记为噪声点(==噪声点就是不属于任何簇的点，从任一核心点出发都是密度不可达的==)。

而dbscan算法的==重点==在于找到某一点的所有密度可达的点。方法是这样的：

1. 检查某一点p的r-邻域内的点是否不少于minpts：
   1. 如果少于则把点p标记为噪声点。
   2. 如果大于则把点p标记为核心点，并把点p标记为核心点，新建簇，并把r-邻域内的点放到候选集合中。
2. 然后遍历候选集合中的点，检查其r-邻域内点的个数：
   1. 如果少于minpts，则标记为边界点。
   2. 如果大于minpts，则标记为核心点，并把r-邻域内的点添加到候选集合中。
3. 重复步骤二，直到候选集合为空，这样一个簇就形成了。



dbscan算法用在路线聚类中：

我们把eps抽象成==相似度==。初始值是50。最大值100（说明完全相似），最小值0。

把minpts抽象成==与路线相似的个数==，一般把minpts尽量设置的小一点，初始值设为1。

聚类：因为一般界面都是显示3条路，所以要聚成3个簇。

## 怎么让他聚成三个类呢?

minpts不变，不断去调整eps(也就是相似度)。

1. 如果聚成的簇比期望的少，说明半径大了，需要减小半径eps = (min + curr)/2；

2. 如果聚成的簇比期望的多，说明半径小了，需要增大半径eps = (max + curr)/2。

## 相似度是怎么计算的。

在使用dbscan算法之前要先计算相似度！！！ 相似度计算规则是这样的：

路线之间两两比较，计算出两条路线中相同的路段长度，然后除以两条路线长度较小的那条，算出一个百分比。

==`sharedLength / min(route1Length, route2length)`==



## 聚类后组内排序的规则

聚成三个簇之后，在每个簇中进行排序，排序是有一个策略：

每条路线根据路线总长度，eta，红绿灯个数(就是乘以一个系数)，综合计算出一个值，根据这个值去排序。

# 地图匹配算法

![image-20230321133820237](image/image-20230321133820237.png)

地图匹配使用的是隐式马尔可夫+维特比算法。

隐马有三类问题：就是已知观测序列、隐藏序列、模型参数(观测概率、转移概率)，其中两个求第三个。

==维特比算法就是：已知观测概率和模型参数求解隐藏序列的问题。==

一般使用色子问题来模拟这一过程。

维特比算法流程：

1. 先算出起始时刻的状态的概率。
2. 然后根据前一状态的概率、当前状态的观测概率、前一状态转移到当前状态的概率计算出当前状态的概率。P(当前状态概率)=P(前一状态概率) * P（观测概率) * P(前一状态概率转移到当前状态的概率)。
3. 重复步骤2,直到最后时刻。
4. 然后找到最后时刻中，概率最大的状态，然后进行回溯一直到起始状态，这是最大概率的隐藏序列。

我们把隐式马尔可夫的某一时刻用gps点来表示，某一时刻的n个状态就是有多少条路段。每次向前扩散，扩散距离最长不超过100米，一个link代表一个状态。

## 初始代价计算？

<u>根据起始的==gps点==在半径200米范围内抓路，每抓到一个路段作为就起始时刻的一个状态。然后计算初始状态的代价</u>，这就涉及到下面的观测代价的计算。

<u>然后求下一时刻(gps点)中可能的状态。</u>

## 下一时刻的状态如何获得？

<u>从第二个点开始就不再继续抓路了，而是从前一个路段向外==扩散==（找出边）。扩散完成后就要计算当前路段的[观测代价](#观测代价模型)和[转换代价](#转换代价模型)了，从而计算出当前状态的代价。为了计算方便我们把**概率转成成代价**，把概率相乘转换成**代价相加**。</u>

### 扩散距离如何计算？

有一个公式：==上一个gps和当前gps点两点之间的距离 * 3 / 2==。

如果碰到转向，则要适当增大扩散距离(两点间距离 * 2)。==转向如何判断？==gps点有方向值，如果上一个点和当前点的角度差大于60表明正在转向。

<u>扩散距离最大不能超过100米。</u>

### 当前状态的代价如何计算？

当前状态的代价 = 上一状态的代价(最小值) + 观测代价 + 上一状态转换到当前状态的代价。

下面就涉及到如何求解观测代价和转换代价。



## 观测代价模型<a id="观测代价模型"></a>

首先根据gps点在当前路段上面抓路(==投影==)，会得到一个grabinfo，根据grabinfo中的**距离偏差**(devation)和**角度偏差(**angleDeviation)乘以相关的系数得到==观测代价值==。

==距离偏差==：gps点到路段的距离。

==角度偏差==：gps点的方向与路段的方向差。

### 投影怎么计算？<a id="投影"></a>

图吧有个库函数来计算 任意一点到线段上的距离最近的点。由于路段有可能不是直的，所以<u>遍历线段上的所有形状点</u>，前后两个形状点一组构成一个线段。

**deviation**：就是点到线段的最短距离。 <a id="deviation"></a>

**intersectionDir**：投影点的方向，可以通过投影点的==前一个形状点和后一个形状点==求出，

**angleDeviation**：两个形状点之间的方向(==intersectionDir==)，与gps点的方向相减得到**angleDeviation**。<a id="angleDeviation"></a>

**disBackward**：是投影点到路段起点的长度。这个长度的求法：可以从路段起点开始遍历形状点直到投影点，然后两点之间的距离累加(==因为路线有可能不是笔直的。==) <a id="disBackward"></a>

**disForward**：路段的长度 - disBackward。<a id="disForward"></a>

![image-20230321133708160](image/image-20230321133708160.png)

## 转换代价模型<a id="转换代价模型"></a>

转换代价指的是从上一个点对应的某个路段 到 当前点对应的某个路段的代价。理论上两点之间的距离和两条路段之间的距离是差不多的，方向亦是如此。

1. ==距离差==：上一个gps和当前gps点之间的距离 和 两条路段上两个点(形状点)的距离之差。如果相差太大则增大代价。
2. ==方向差==：上一个gps和当前gps点之间的方向 和 两条路段上两个点(形状点)的方向之差。如果相差太大则增大代价。
3. ==坡度差==：上一个gps和当前gps点之间的坡度 和 两条路段上两个点(形状点)的坡度之差。如果相差太大则增大代价。
4. 从主路进入到辅路则相应的增大代价。（如果设置了主路优先的话。）

### 路段上的坡度怎么计算？

根据的路段上的形状点，不断的累积高度。



## 回溯

最后一步就是回溯了，找到最后gps点所对应所有状态中代价值最小的，然后沿着父状态指针依次往前遍历直到起始状态，这样就找到了gps点所对应的隐藏路线。



# 客户端引擎

## 架构

![image-20230321134203678](image/image-20230321134203678.png)

![image-20230321134311792](image/image-20230321134311792.png)

观察者模式

onlineRouter算路成功通知backgroundRouter(还有offlineRouter)，backgroundRouter通知naviProcess， naviProcess通知naviSession，naviSession再通知各个子模块。naviSession相当于对外的一个接口层。



## 功能

### 拼接各种网络请求

获取沿路adas，获取实时路况和交通事件，

#### 拼接算路请求

比如说：起点、终点、出发时间。

### 导航

#### 导航进度

就是要知道车现在走到哪了。

流程：根据gps点在路段上面抓路([投影](#投影))，最长往前抓300米的路，然后得到一个最好的grabInfo，然后**路段起点**到**路线起点**的长度 + grabInfo.[disBackward](#disBackward),就是已经走过的路径长度。

导航进度再通过naviSession转发给各个子模块。

### 偏航

#### 偏航判定

三条路线是同时在进行偏航判定的。如果偏航就会发生重算路。

##### gps偏航判定

1. 在gps比较可信的情况：==hdop(水平精度因子)>30，但是速度比较大(>10m/s [36km/h])==，根据车道数，车道宽度，车速等因素算出一个阈值。

   如果距离偏差(grabinfo.[deviation](#deviation)) 大于这个阈值，则认为偏航。  

2. 在gps非常可信的情况下：hdop<=30，如果距离偏差[deviation](#deviation)大于10米，角度偏差[angleDeviation](#angleDeviation)大于60度，则认为偏航。

##### 高架偏航判定

惯导数据中有个==高架识别状态==的字段：`enEleRecog EleStatus;`

```c
// 高架识别状态
typedef enum enEleRecog {
	RECOG_NULL = 0,								// 未进行识别
	RECOG_START,								// 开始识别（瞬间点）
	RECOG_ING,									// 正在识别(持续过程)
	RECOG_UP,									// 识别结束，上坡
	RECOG_LEV,									// 识别结束，平坡
	RECOG_DOWN,									// 识别结束，下坡
	RECOG_UNCLEAR								// 识别结束, 识别失败 
} enEleRecog;
```

 路段属性中有个==平行路标记==字段：该字段表明link是**高架道路**还是**高架下道路**。

如果高架识别状态和平行路标记不一致则认为偏航。



##### 坡度偏航判定

总体来说就是判断==路线的高度变化==和==传感器数据中的高度变化==是否接近，如果不接近就认为是偏航。

1. 求路线的高度：**走过的长度 乘以 坡度值(adas点中的slope属性)**就得到了高度。
   - 走过的长度求法：先通过在link上抓路求得grabInfo.[disBackward](#disBackward)，加上路段起点到路线起点的长度，再减去上一次的导航进度，就得到这次走了多长。
2. 求传感器的高度：**走过的长度 乘以 坡度值(传感器中的slope属性)**就得到了高度。

   - 走过的长度求法：车速 乘以 gps采样间隔。
   - 传感器中的slope值：利用陀螺仪、加速度计中的数值结合MadgwickAHRS(马德威克姿态航向参考系统)(马德维克AHRS)算法求得。

3. 求方差：

   总共记录两组样本，每组样本16个，采样频率是根据gps的间隔时间。

   然后两组样本中，相同时刻的值进行相减，相减之后得到一组数据进行求==方差==。大于0.35认为是相似，小于0.35不相似。

   1. 方差 > 0.35：认为高度变化是相似的。
   2. 方差 < 0.2：认为是不相似的。
   3. 0.2 < 方差 < 0.35：认为不确定。

方差 =  $\frac{\sum(X-\mu)^2}{N}$           X：样本值。$\mu$：样本均值。N：样本个数。

$$\frac{1^2}{2}$$



切路

播报：guidance

数据商店



