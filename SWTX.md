



# 选路算法

主要使用dbscan算法。dbscan算法有两个重要的参数，eps和minpts：eps代表邻域的半径，minpts代表邻域内至少有多少点。

dbscan算法的主要流程就是：

1. 第一步先初始化，把所有点标记为未访问的。
2. 然后第二步，在数据集中任选一点p，找到从点p出发所有与它密度相连的点，形成一个簇。
3. 第三步，重复步骤二，直到数据集中的所有点都被访问或者被标记为噪声点(==噪声点就是不属于任何簇的点，从任一核心点出发都是密度不可达的==)。

而dbscan算法的重点在于找到某一点的所有密度可达的点。方法是这样的：

1. 检查某一点p的r-邻域内的点是否不少于minpts：
   1. 如果少于则把点p标记为噪声点。
   2. 如果大于则把点p标记为核心点，并把点p标记为核心点，新建簇，并把r-邻域内的点放到候选集合中。
2. 然后遍历候选集合中的点，检查其r-邻域内点的个数：
   1. 如果少于minpts，则标记为边界点。
   2. 如果大于minpts，则标记为核心点，并把r-邻域内的点添加到候选集合中。
3. 重复步骤二，直到候选集合为空，这样一个簇就形成了。



dbscan算法用在路线聚类中：

我们把eps抽象成==相似度==。初始值是50。最大值100（说明完全相似），最小值0。

把minpts抽象成==与路线相似的个数==，一般把minpts尽量设置的小一点，初始值设为1。

聚类：因为一般界面都是显示3条路，所以要聚成3个簇。

## 怎么让他聚成三个类呢?

minpts不变，不断去调整eps(也就是相似度)。

1. 如果聚成的簇比期望的少，说明半径大了，需要减小半径eps = (min + curr)/2；

2. 如果聚成的簇比期望的多，说明半径小了，需要增大半径eps = (max + curr)/2。

## 相似度是怎么计算的。

在使用dbscan算法之前要先计算相似度！！！ 相似度计算规则是这样的：

路线之间两两比较，计算出两条路线中相同的路段长度，然后除以两条路线长度较小的那条，算出一个百分比。

==`sharedLength / min(route1Length, route2length)`==



聚成三个簇之后，在每个簇中进行排序，排序是有一个策略：

每条路线根据路线总长度，eta，红绿灯个数(就是乘以一个系数)，综合计算出一个值，根据这个值去排序。



# 地图匹配算法

地图匹配使用的是隐式马尔可夫+维特比算法。

隐马有三类问题：就是已知观测序列、隐藏序列、模型参数(观测概率、转移概率)，其中两个求第三个。

维特比算法就是：已知观测概率和模型参数求解隐藏序列的问题。

一般使用色子问题来模拟这一过程。

维特比算法流程：

1. 先算出起始时刻的状态的概率。
2. 然后根据前一状态的概率、当前状态的观测概率、前一状态转移到当前状态的概率计算出当前状态的概率。P(当前状态概率)=P(前一状态概率) * P（观测概率) * P(前一状态概率转移到当前状态的概率)。
3. 重复步骤2,直到最后时刻。
4. 然后找到最后时刻中，概率最大的状态，然后进行回溯一直到起始状态，这是最大概率的隐藏序列。



我们把隐式马尔可夫的某一时刻用gps点来表示，某一时刻的n个状态就是 有多少条路段。

每次向前扩散，扩散距离最长不超过100米，一个link代表一个状态。

初始概率计算：

200米范围内抓路



下一时刻的状态如何获得？

找出边。

当前状态的概率如何计算？



观测概率模型：

距离、角度

转换概率模型：

距离、角度









