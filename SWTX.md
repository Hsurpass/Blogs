



# 选路算法

主要使用dbscan算法。dbscan算法有两个重要的参数，eps和minpts：eps代表邻域的半径，minpts代表邻域内至少有多少点。

dbscan算法的主要流程就是：

1. 第一步先初始化，把所有点标记为未访问的。
2. 然后第二步，在数据集中任选一点p，找到从点p出发所有与它密度相连的点，形成一个簇。
3. 第三步，重复步骤二，直到数据集中的所有点都被访问或者被标记为噪声点(==噪声点就是不属于任何簇的点，从任一核心点出发都是密度不可达的==)。

而dbscan算法的重点在于找到某一点的所有密度可达的点。方法是这样的：

1. 检查某一点p的r-邻域内的点是否不少于minpts：
   1. 如果少于则把点p标记为噪声点。
   2. 如果大于则把点p标记为核心点，并把点p标记为核心点，新建簇，并把r-邻域内的点放到候选集合中。
2. 然后遍历候选集合中的点，检查其r-邻域内点的个数：
   1. 如果少于minpts，则标记为边界点。
   2. 如果大于minpts，则标记为核心点，并把r-邻域内的点添加到候选集合中。
3. 重复步骤二，直到候选集合为空，这样一个簇就形成了。



dbscan算法用在路线聚类中：

我们把eps抽象成==相似度==。初始值是50。最大值100（说明完全相似），最小值0。

把minpts抽象成==与路线相似的个数==，一般把minpts尽量设置的小一点，初始值设为1。

聚类：因为一般界面都是显示3条路，所以要聚成3个簇。

## 怎么让他聚成三个类呢?

minpts不变，不断去调整eps(也就是相似度)。

1. 如果聚成的簇比期望的少，说明半径大了，需要减小半径eps = (min + curr)/2；

2. 如果聚成的簇比期望的多，说明半径小了，需要增大半径eps = (max + curr)/2。

## 相似度是怎么计算的。

在使用dbscan算法之前要先计算相似度！！！ 相似度计算规则是这样的：

路线之间两两比较，计算出两条路线中相同的路段长度，然后除以两条路线长度较小的那条，算出一个百分比。

==`sharedLength / min(route1Length, route2length)`==



聚成三个簇之后，在每个簇中进行排序，排序是有一个策略：

每条路线根据路线总长度，eta，红绿灯个数(就是乘以一个系数)，综合计算出一个值，根据这个值去排序。

